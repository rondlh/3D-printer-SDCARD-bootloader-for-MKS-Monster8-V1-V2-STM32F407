<!DOCTYPE html>
<html lang="en"><!-- Beautiful Jekyll | MIT license | Copyright Dean Attali 2020 --><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Tutorial: An SD card over SPI using STM32CubeIDE and FatFS</title>
  
  
  <meta name="author" content="Hammond Pearce">
  
  
  
  <meta name="description" content="Let's have some fun with files">
  

  <link rel="alternate" type="application/rss+xml" title="projects by kiwih - I like to tinker and make things and sometimes write about what I've done" href="https://01001000.xyz/feed.xml">

  

  

  
<!-- Google Analytics -->
<script async="" src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/google-analytics_analytics.js"></script><script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date(); a = s.createElement(o),
      m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-165236652-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



  
    
      
  <link href="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/all.min.css">


    
      
  <link rel="stylesheet" href="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/css_002.css">


    
      
  <link rel="stylesheet" href="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/css.css">


    
  

  
    
      <link rel="stylesheet" href="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/bootstrap-social.css">
    
      <link rel="stylesheet" href="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/main.css">
    
  

  

  

  <!-- Facebook OpenGraph tags -->
  

  
  <meta property="og:title" content="Tutorial: An SD card over SPI using STM32CubeIDE and FatFS">
  

   
  <meta property="og:description" content="Let's have some fun with files">
  


  <meta property="og:type" content="website">

  
  <meta property="og:url" content="https://01001000.xyz/2020-08-09-Tutorial-STM32CubeIDE-SD-card/">
  <link rel="canonical" href="https://01001000.xyz/2020-08-09-Tutorial-STM32CubeIDE-SD-card/">
  

  
  <meta property="og:image" content="https://01001000.xyz/assets/img/cubeide-sd-card/module-wired.png">
  


  <!-- Twitter summary cards -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@">
  <meta name="twitter:creator" content="@">

  
  <meta name="twitter:title" content="Tutorial: An SD card over SPI using STM32CubeIDE and FatFS">
  

  
  <meta name="twitter:description" content="Let's have some fun with files">
  

  
  <meta name="twitter:image" content="/assets/img/cubeide-sd-card/module-wired.png">
  

  

  

</head>


  <body>

    

  
    <nav class="navbar navbar-expand-md navbar-light fixed-top navbar-custom top-nav-short"><a class="navbar-brand" href="https://01001000.xyz/">projects by kiwih</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="https://01001000.xyz/tags/#STM32CubeIDE">STM32CubeIDE Tutorials</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://01001000.xyz/aboutme">About Me</a>
          </li></ul>
  </div>

  
    <div class="avatar-container">
      <div class="avatar-img-border">
        <a href="https://01001000.xyz/">
          <img alt="Navbar avatar" class="avatar-img" src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/logo.png">
        </a>
      </div>
    </div>
  

</nav>


    <!-- TODO this file has become a mess, refactor it -->







<header class="header-section ">

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>Tutorial: An SD card over SPI using STM32CubeIDE and FatFS</h1>
      
        
      <h2 class="post-subheading">Let's have some fun with files</h2>
      
      
      
      
          <span class="post-meta">Posted on August 9, 2020</span>
          
      
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class="container-md">
  <div class="row">
    <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">

      
        
        
        

        <div id="header-gh-btns">
          
            
              
                  <iframe src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/github-btn.htm" frameborder="0" scrolling="0" width="120px" height="20px"></iframe>
                
            
              
                  <iframe src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/github-btn_002.htm" frameborder="0" scrolling="0" width="120px" height="20px"></iframe>
                
            
              
                  <iframe src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/github-btn_003.htm" frameborder="0" scrolling="0" width="220px" height="20px"></iframe>
              
            
          
        </div>
      

      
        <div class="blog-tags">
          Tags:
          
          
            <a href="https://01001000.xyz/tags#tutorial">tutorial</a>
          
            <a href="https://01001000.xyz/tags#stm32">stm32</a>
          
            <a href="https://01001000.xyz/tags#STM32CubeIDE">STM32CubeIDE</a>
          
            <a href="https://01001000.xyz/tags#embedded">embedded</a>
          
            <a href="https://01001000.xyz/tags#c">c</a>
          
          
        </div>
      

      <article role="main" class="blog-post">
        <p>Embedded projects often call for some kind of data storage and retrieval. 
For instance, you might have need for a data logger to record data points over long periods of time.
You might have user settings that need to be preserved after the device is shut off and rebooted.
You might want to profile your application, or debug certain features.</p>

<p>There are a number of ways to do this, and one of my favourites is to
 add an SD (or other memory) card to a project. 
It’s not too complicated, and it adds a lot of flexibility, as you can 
easily take the SD card out of the project and examine it with another 
machine.
My second favourite method is to slap on a 20 cent EEPROM, but while 
that’s cheaper it’s a lot less flexible and usually stores a lot less 
data!</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/sd-card.png" alt="SD card" class="mx-auto d-block"></p>

<p>I’ve been asked more than once if I have any good tutorial resources for adding SD cards to an embedded project. 
Well, there are a few good tutorials and resources floating around online (including even <a href="https://01001000.xyz/2017-08-17-CubeMX-SD-card">my own resource from 2017</a>) but some of them are a bit dated, relying on older tools and libraries.
Further, while there are some <em>amazing</em> resources (e.g. <a href="http://elm-chan.org/docs/mmc/mmc_e.html">ChaN’s</a>)
 on talking to SD cards over SPI, there are less that describe how to 
interface this with file systems such as FAT, and less again that 
describe how to do it while also working with STM32’s build 
environments.
Complicating matters is that officially you should use the STM32 SDIO 
peripheral to interface with an SD card - however, not all STM32s have 
the SDIO peripheral, leaving us to fall back on the SPI method (That 
said, it is worth noting that <em>not all SD cards support the SPI interface</em>).</p>

<p>Well, in this tutorial I’m going to walk through the steps that one 
would use to get an SD card working over the SPI interface on a STM32 
dev board (re-)using my FatFS driver from 2017. 
FatFS is an amazing open source project <a href="http://elm-chan.org/fsw/ff/00index_e.html">also provided by ChaN</a>
 which has since been integrated into the STM32Cube tools.
If you’re interfacing with an SD card using the SDIO peripheral, it’s 
pretty easy and the tooling does most of it for you.
If you’re working with other kinds of configurations, e.g. SD card over 
SPI, it’s actually still pretty easy - you just need the appropriate 
driver!
So, today I want to show how you can use the FatFS libraries within the 
STM32CubeIDE development environment, and show how you can simply drop 
in the appropriate SPI driver to make everything work.</p>

<p>I’ll be assuming that you already know the basics of creating a project and setting up debugging and so on.
If not, then please <a href="https://01001000.xyz/2020-05-11-Tutorial-STM32CubeIDE-Getting-started/">check out this earlier tutorial, in which I walk through getting started with STM32CubeIDE</a>.</p>

<p>TL;DR: CubeIDE with FatFS. The complete code project is available <a href="https://github.com/kiwih/cubeide-sd-card">here</a>.</p>

<h1 id="equipment-for-this-tutorial">Equipment for this tutorial</h1>

<p>Today I will be using the following:</p>

<ul>
  <li>(Free) Ubuntu Linux 20.04 because developing on Linux makes me 
happy and Ubuntu makes it easy. Don’t worry if you’re on Windows, you 
should be able to follow along with roughly the same steps.</li>
  <li>(Free) STM32CubeIDE</li>
  <li>($19.95 from <a href="https://amzn.to/2BDK6ID">Amazon Prime</a>, $15.05 from <a href="https://amzn.to/3gEp6AA">Amazon</a>) The <code class="language-plaintext highlighter-rouge">Nucleo-F303RE</code> development board.</li>
  <li>($5 from <a href="https://amzn.to/3ik1wJV">Amazon Prime</a>) An SD card breakout board (comes in a pack of two).</li>
  <li>($6 from <a href="https://amzn.to/33GRwXe">Amazon Prime</a>) Easy-to-use ribbon cables (there’s more than you need here but they’re handy to have around).</li>
  <li>A micro SD card - note that <em>not all SD cards will work in SPI mode</em>. I have an Apacer one that works, and a Kingston one that does not. YMMV.</li>
</ul>

<p><em>Note: The above Amazon links are affiliate links. As always I 
encourage you to shop around, but Amazon usually has pretty good 
pricing.</em></p>

<h1 id="the-software-stack">The software stack</h1>

<p>In this blog post I’m not terribly interested in the low-level 
behaviour we’re using to get an SD card working beyond “we talk to it 
over SPI”. 
It’s worth knowing though, so go <a href="http://elm-chan.org/docs/mmc/mmc_e.html">check out what ChaN wrote</a>,
 and then come back.
The key knowledge that I want to show in this tutorial is around the 
architecture of an embedded application that wants to use an SD card 
with a FAT file system (using the FatFS library).</p>

<p>In general it’s always useful to visualise the architecture of what you are working with. In a FatFS system it looks like this:</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/stack.png" alt="Architecture with FatFS" class="mx-auto d-block"></p>

<p>FatFS is provided as a <em>Middleware</em> which can translate FAT file structures in memory into their actual files. Handy!
For it to do its magic, it needs access to a storage medium. It relies on several functions as ChaN notes here:</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/fatfs-functions.png" alt="FatFS functions" class="mx-auto d-block"></p>

<p>It’s these functions that we’ll need to provide. 
For an SD card they’re pretty involved, but don’t worry, we’ll just be dropping in a pre-existing driver and linking it up.</p>

<h1 id="setting-up-the-project-and-pins">Setting up the Project and Pins</h1>

<ol>
  <li>Open STM32CubeIDE.</li>
  <li>Start a new project for the <code class="language-plaintext highlighter-rouge">Nucleo-F303RE</code> dev board (or w/e you’re using) called something sensible e.g. <em>cubeide-sd-card</em>.</li>
  <li>Answer ‘Yes’ to <em>Initialize all peripherals in their default configuration?</em>.</li>
  <li>Answer ‘Yes’ to <em>Open device configuration view?</em>.</li>
</ol>

<p>The Device Configuration View is where you configure exactly which pins/peripherals are enabled and what their settings are.
Since we want to be connecting to an SD card, we need to enable an SPI port and then decide where to wire it.</p>

<p>Let’s quickly work out where our pins are going. Our goal here is to 
identify an SPI peripheral with easy-to-access pins as well as a GPIO 
pin to use as a <em>chip select</em>.</p>

<p>On the <code class="language-plaintext highlighter-rouge">Nucleo-F303-RE</code> we have both Arduino style headers as well as ST’s branded <em>morpho</em>
 headers, which are the double rows of pins down each side. 
While it’s tempting to use the Arduino header’s SPI port (since it’s 
labelled on the silk screen) I actually don’t like to, as the on-board 
LED shares one of the pins (one of the worst features of this particular
 development kit).
So, instead I will take a look at the morpho header pinouts.</p>

<p><a href="https://www.st.com/resource/en/user_manual/dm00105823-stm32-nucleo-64-boards-mb1136-stmicroelectronics.pdf">This document</a>
 from ST provides us with the correct pinout for the F303-RE, or 
alternatively (and in a more attractive and detailed way) the same info 
is presented on ST’s mbed OS website <a href="https://os.mbed.com/platforms/ST-Nucleo-F303RE/">here</a>.</p>

<p>Straight away I can see that SPI2 is the winner - it is broken out 
onto the pins in the bottom right, along with PB1 which we will use for 
the chip select line.</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/nucleo_f303re_morpho_spi2.png" alt="SPI2 Pins" class="mx-auto d-block"></p>

<p>So, let’s set up our SPI2 and GPIO in the Device Configuration View. 
Click SPI2 on the left, and then set it to Full Duplex Master with no 
Hardware NSS.
Then set the Data Size to 8 bits, and the clock prescaler to 128 (SD 
cards start up with low speeds and switch to higher speeds later. We’ll 
look at how to do this soon).</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/cubeide-spi2-setup.png" alt="SPI2 Config" class="mx-auto d-block"></p>

<p>Then, create your Chip Select line on PB1 - I find setting a sensible name is also good:</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/cubeide-sd-cs-setup.png" alt="SD_CS Config" class="mx-auto d-block"></p>

<p>Finally, as we’re going to be using the SD card with the FAT file system, scroll down in the device categories to <code class="language-plaintext highlighter-rouge">Middleware</code>, and expand this, then enable <code class="language-plaintext highlighter-rouge">FATFS</code> as <code class="language-plaintext highlighter-rouge">User-defined</code>. You may leave all other parameters as their defaults.</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/cubeide-fatfs-setup.png" alt="FATFS Config" class="mx-auto d-block"></p>

<p>Now save your Device Configuration, and when it asks, ‘Yes’ to <em>Do you want to generate Code?</em> and ‘Yes’ to <em>Do you want to open [the C/C++] perspective now?</em>.</p>

<h1 id="wiring-the-sd-card-adapter">Wiring the SD card adapter</h1>

<p>Now that you have configured the pins in CubeIDE, we need to physically wire them in real life!</p>

<p>Using the SPI pins from the earlier figure, and the power pins depicted here,</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/nucleo_f303re_morpho_power.png" alt="Power Pins" class="mx-auto d-block"></p>

<p>Use your ribbon cables and connect these to the appropriate pins on 
the SD card adapter module (the module’s pins are labelled on the silk 
screen, so this isn’t much of a chore).</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/module-labels.png" alt="SD adapter silkscreen labels" class="mx-auto d-block"></p>

<p>In table form, the connections are as follows:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">SD Adapter side</th>
      <th style="text-align: left"><code class="language-plaintext highlighter-rouge">Nucleo-F303RE</code> side</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">CS</td>
      <td style="text-align: left">PB1 (GPIO SD_CS)</td>
    </tr>
    <tr>
      <td style="text-align: left">SCK</td>
      <td style="text-align: left">PB13 (SPI2 SCLK)</td>
    </tr>
    <tr>
      <td style="text-align: left">MOSI</td>
      <td style="text-align: left">PB15 (SPI2 MOSI)</td>
    </tr>
    <tr>
      <td style="text-align: left">MISO</td>
      <td style="text-align: left">PB14 (SPI2 MISO)</td>
    </tr>
    <tr>
      <td style="text-align: left">VCC</td>
      <td style="text-align: left">5V</td>
    </tr>
    <tr>
      <td style="text-align: left">GND</td>
      <td style="text-align: left">GND</td>
    </tr>
  </tbody>
</table>

<p>Once you’re finished it should look something like this:</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/module-wired.png" alt="Wired up" class="mx-auto d-block"></p>

<h1 id="key-files-to-make-this-work">Key files to make this work</h1>

<p>It’s now time to put our driver in. 
<a href="https://01001000.xyz/2017-08-17-CubeMX-SD-card">In 2017 I worked with some of ChaN’s source code to produce a driver compatible with the predecessor to CubeIDE, CubeMX</a>. 
This driver will work with CubeIDE, but I’ve made a few changes to update it (and make it better).
It has two files, <code class="language-plaintext highlighter-rouge">user_diskio_spi.c</code> which you can get <a href="https://github.com/kiwih/cubeide-sd-card/blob/master/cubeide-sd-card/FATFS/Target/user_diskio_spi.c">here</a>, and <code class="language-plaintext highlighter-rouge">user_diskio_spi.h</code> which you can get <a href="https://github.com/kiwih/cubeide-sd-card/blob/master/cubeide-sd-card/FATFS/Target/user_diskio_spi.h">here</a>.</p>

<p>Download these and copy them into your <code class="language-plaintext highlighter-rouge">FATFS/Target</code> directory (you can also copy them into <code class="language-plaintext highlighter-rouge">Core/Src</code> and <code class="language-plaintext highlighter-rouge">Core/Inc</code> respectively if you’d prefer, but I think that’s messier).</p>

<p>When you’ve done this, your file viewer should now look something like this:</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/cubeide-files.png" alt="Files" class="mx-auto d-block"></p>

<p>Now we need to link the driver into FatFS. This will involve just a simple change to the <code class="language-plaintext highlighter-rouge">user_diskio.c</code>
 file. There are more elegant ways to do this, but if we’re not careful 
we will fall afoul of the STM32CubeIDE code generator, so we are limited
 to changing code in the commented areas.</p>

<p>What we’re going to do is embed calls to the SPI driver functions in each of the autogenerated driver stubs.
I’ve annotated the changes below with <code class="language-plaintext highlighter-rouge">//ADD THIS LINE</code>. You’ll see that each of the function calls just calls the appropriate function in our driver.</p>

<p><em>In <code class="language-plaintext highlighter-rouge">user_diskio.c</code> Decl:</em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* USER CODE BEGIN DECL */</span>

<span class="cm">/* Includes ------------------------------------------------------------------*/</span>
<span class="cp">#include &lt;string.h&gt;
#include "ff_gen_drv.h"
#include "user_diskio_spi.h"
</span></code></pre></div></div>

<p><em>In <code class="language-plaintext highlighter-rouge">user_diskio.c</code> Private Functions:</em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Private functions ---------------------------------------------------------*/</span>

<span class="cm">/**
  * @brief  Initializes a Drive
  * @param  pdrv: Physical drive number (0..)
  * @retval DSTATUS: Operation status
  */</span>
<span class="n">DSTATUS</span> <span class="nf">USER_initialize</span> <span class="p">(</span>
	<span class="n">BYTE</span> <span class="n">pdrv</span>           <span class="cm">/* Physical drive nmuber to identify the drive */</span>
<span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* USER CODE BEGIN INIT */</span>
	<span class="k">return</span> <span class="n">USER_SPI_initialize</span><span class="p">(</span><span class="n">pdrv</span><span class="p">);</span> <span class="c1">//ADD THIS LINE</span>
  <span class="cm">/* USER CODE END INIT */</span>
<span class="p">}</span>

<span class="cm">/**
  * @brief  Gets Disk Status
  * @param  pdrv: Physical drive number (0..)
  * @retval DSTATUS: Operation status
  */</span>
<span class="n">DSTATUS</span> <span class="nf">USER_status</span> <span class="p">(</span>
	<span class="n">BYTE</span> <span class="n">pdrv</span>       <span class="cm">/* Physical drive number to identify the drive */</span>
<span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* USER CODE BEGIN STATUS */</span>
	<span class="k">return</span> <span class="n">USER_SPI_status</span><span class="p">(</span><span class="n">pdrv</span><span class="p">);</span> <span class="c1">//ADD THIS LINE</span>
  <span class="cm">/* USER CODE END STATUS */</span>
<span class="p">}</span>

<span class="cm">/**
  * @brief  Reads Sector(s)
  * @param  pdrv: Physical drive number (0..)
  * @param  *buff: Data buffer to store read data
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */</span>
<span class="n">DRESULT</span> <span class="nf">USER_read</span> <span class="p">(</span>
	<span class="n">BYTE</span> <span class="n">pdrv</span><span class="p">,</span>      <span class="cm">/* Physical drive nmuber to identify the drive */</span>
	<span class="n">BYTE</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span>     <span class="cm">/* Data buffer to store read data */</span>
	<span class="n">DWORD</span> <span class="n">sector</span><span class="p">,</span>   <span class="cm">/* Sector address in LBA */</span>
	<span class="n">UINT</span> <span class="n">count</span>      <span class="cm">/* Number of sectors to read */</span>
<span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* USER CODE BEGIN READ */</span>
	<span class="k">return</span> <span class="n">USER_SPI_read</span><span class="p">(</span><span class="n">pdrv</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> <span class="c1">//ADD THIS LINE</span>
  <span class="cm">/* USER CODE END READ */</span>
<span class="p">}</span>

<span class="cm">/**
  * @brief  Writes Sector(s)
  * @param  pdrv: Physical drive number (0..)
  * @param  *buff: Data to be written
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */</span>
<span class="cp">#if _USE_WRITE == 1
</span><span class="n">DRESULT</span> <span class="nf">USER_write</span> <span class="p">(</span>
	<span class="n">BYTE</span> <span class="n">pdrv</span><span class="p">,</span>          <span class="cm">/* Physical drive nmuber to identify the drive */</span>
	<span class="k">const</span> <span class="n">BYTE</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span>   <span class="cm">/* Data to be written */</span>
	<span class="n">DWORD</span> <span class="n">sector</span><span class="p">,</span>       <span class="cm">/* Sector address in LBA */</span>
	<span class="n">UINT</span> <span class="n">count</span>          <span class="cm">/* Number of sectors to write */</span>
<span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* USER CODE BEGIN WRITE */</span>
  <span class="cm">/* USER CODE HERE */</span>
	<span class="k">return</span> <span class="n">USER_SPI_write</span><span class="p">(</span><span class="n">pdrv</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> <span class="c1">//ADD THIS LINE</span>
  <span class="cm">/* USER CODE END WRITE */</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* _USE_WRITE == 1 */</span><span class="cp">
</span>
<span class="cm">/**
  * @brief  I/O control operation
  * @param  pdrv: Physical drive number (0..)
  * @param  cmd: Control code
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */</span>
<span class="cp">#if _USE_IOCTL == 1
</span><span class="n">DRESULT</span> <span class="nf">USER_ioctl</span> <span class="p">(</span>
	<span class="n">BYTE</span> <span class="n">pdrv</span><span class="p">,</span>      <span class="cm">/* Physical drive nmuber (0..) */</span>
	<span class="n">BYTE</span> <span class="n">cmd</span><span class="p">,</span>       <span class="cm">/* Control code */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buff</span>      <span class="cm">/* Buffer to send/receive control data */</span>
<span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* USER CODE BEGIN IOCTL */</span>
	<span class="k">return</span> <span class="n">USER_SPI_ioctl</span><span class="p">(</span><span class="n">pdrv</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span> <span class="c1">//ADD THIS LINE</span>
  <span class="cm">/* USER CODE END IOCTL */</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* _USE_IOCTL == 1 */</span><span class="cp">
</span>
</code></pre></div></div>

<p>Finally, for our driver to work, we need to make just one more change - we need to tell it which SPI we are using!
You’ll notice at the top of <code class="language-plaintext highlighter-rouge">user_diskio_spi.c</code> the following snippet:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Make sure you set #define SD_SPI_HANDLE as some hspix in main.h</span>
<span class="c1">//Make sure you set #define SD_CS_GPIO_Port as some GPIO port in main.h</span>
<span class="c1">//Make sure you set #define SD_CS_Pin as some GPIO pin in main.h</span>
<span class="k">extern</span> <span class="n">SPI_HandleTypeDef</span> <span class="n">SD_SPI_HANDLE</span><span class="p">;</span>
</code></pre></div></div>

<p>So this is what we need to do now. Pop over into <code class="language-plaintext highlighter-rouge">main.h</code>. You’ll see thanks to our Device configuration from earlier that <code class="language-plaintext highlighter-rouge">SD_CS_GPIO_Port</code> and <code class="language-plaintext highlighter-rouge">SD_CS_Pin</code> are already set for us, so we only need to add the following line:</p>

<p><em>in <code class="language-plaintext highlighter-rouge">main.h</code> Private defines:</em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* USER CODE BEGIN Private defines */</span>
<span class="cp">#define SD_SPI_HANDLE hspi2
</span><span class="cm">/* USER CODE END Private defines */</span>
</code></pre></div></div>

<p>Finally, we need to consider the clock speeds for our SD card driver. If you’re using the <code class="language-plaintext highlighter-rouge">Nucleo-F303RE</code>, great, the defaults are what I was using.
If not, open up <code class="language-plaintext highlighter-rouge">user_diskio_spi.c</code> and just make sure these prescalar values work for you to generate approximately the listed speeds:</p>

<p><em>in <code class="language-plaintext highlighter-rouge">user_diskio_spi.c:</code></em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//(Note that the _256 is used as a mask to clear the prescalar bits as it provides binary 111 in the correct position)</span>

<span class="cp">#define FCLK_SLOW() { MODIFY_REG(SD_SPI_HANDLE.Instance-&gt;CR1, SPI_BAUDRATEPRESCALER_256, SPI_BAUDRATEPRESCALER_128); }	</span><span class="cm">/* Set SCLK = slow, approx 280 KBits/s*/</span><span class="cp">
#define FCLK_FAST() { MODIFY_REG(SD_SPI_HANDLE.Instance-&gt;CR1, SPI_BAUDRATEPRESCALER_256, SPI_BAUDRATEPRESCALER_8); }	</span><span class="cm">/* Set SCLK = fast, approx 4.5 MBits/s */</span><span class="cp">
</span></code></pre></div></div>

<p>We’re ready to go!</p>

<h1 id="testing-and-correct-output">Testing and correct output</h1>

<p>First, ensure your micro SD card is formatted to the FAT file system 
(in your operating system of choice just insert the SD card and then 
format it to FAT32/FAT/msdos - <em>not</em> exFAT).</p>

<p>Then, create a file <code class="language-plaintext highlighter-rouge">test.txt</code> in the root of your SD card. Puyt something in it, e.g. <code class="language-plaintext highlighter-rouge">Hello I'm on an SD card</code>. Save the file and remove the SD card from your computer.</p>

<p>Now plug the SD card into the module, and connect the development kit
 to your PC. We’re going to make output will be coming via the 
integrated COM port, so make sure you open that up using either e.g. 
minicom (Ubuntu) or PuTTY (Windows).</p>

<p>Now let’s add some code to <code class="language-plaintext highlighter-rouge">main.c</code>. We’re going to want a <code class="language-plaintext highlighter-rouge">printf</code> that outputs to the integrated terminal, so we need to add a few things:</p>

<p><em>in <code class="language-plaintext highlighter-rouge">main.c</code> Private includes:</em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Private includes ----------------------------------------------------------*/</span>
<span class="cm">/* USER CODE BEGIN Includes */</span>
<span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt; //for va_list var arg functions
</span><span class="cm">/* USER CODE END Includes */</span>

</code></pre></div></div>

<p><em>in <code class="language-plaintext highlighter-rouge">main.c</code> Private function prototypes:</em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* USER CODE BEGIN PFP */</span>
<span class="kt">void</span> <span class="nf">myprintf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="cm">/* USER CODE END PFP */</span>
</code></pre></div></div>

<p><em>in <code class="language-plaintext highlighter-rouge">main.c</code> User Code 0:</em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* USER CODE BEGIN 0 */</span>
<span class="kt">void</span> <span class="nf">myprintf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
  <span class="n">vsnprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
  <span class="n">HAL_UART_Transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huart2</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="p">}</span>
<span class="cm">/* USER CODE END 0 */</span>
</code></pre></div></div>

<p>Great, that will let us call <code class="language-plaintext highlighter-rouge">myprintf()</code> as if it was any other <code class="language-plaintext highlighter-rouge">printf</code> with strings of up to 256 characters and the output will come out on UART2 (the virtual COM port).</p>

<p>Now let’s add some file system fun!</p>

<p><em>in <code class="language-plaintext highlighter-rouge">main.c</code> From User Code 2 to User Code 3 (inside the main() function):</em></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/* USER CODE BEGIN 2 */</span>

  <span class="n">myprintf</span><span class="p">(</span><span class="s">"</span><span class="se">\r\n</span><span class="s">~ SD card demo by kiwih ~</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="c1">//a short delay is important to let the SD card settle</span>

  <span class="c1">//some variables for FatFs</span>
  <span class="n">FATFS</span> <span class="n">FatFs</span><span class="p">;</span> 	<span class="c1">//Fatfs handle</span>
  <span class="n">FIL</span> <span class="n">fil</span><span class="p">;</span> 		<span class="c1">//File handle</span>
  <span class="n">FRESULT</span> <span class="n">fres</span><span class="p">;</span> <span class="c1">//Result after operations</span>

  <span class="c1">//Open the file system</span>
  <span class="n">fres</span> <span class="o">=</span> <span class="n">f_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">FatFs</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//1=mount now</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fres</span> <span class="o">!=</span> <span class="n">FR_OK</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"f_mount error (%i)</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fres</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//Let's get some statistics from the SD card</span>
  <span class="n">DWORD</span> <span class="n">free_clusters</span><span class="p">,</span> <span class="n">free_sectors</span><span class="p">,</span> <span class="n">total_sectors</span><span class="p">;</span>

  <span class="n">FATFS</span><span class="o">*</span> <span class="n">getFreeFs</span><span class="p">;</span>

  <span class="n">fres</span> <span class="o">=</span> <span class="n">f_getfree</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_clusters</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">getFreeFs</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fres</span> <span class="o">!=</span> <span class="n">FR_OK</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"f_getfree error (%i)</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fres</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//Formula comes from ChaN's documentation</span>
  <span class="n">total_sectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">getFreeFs</span><span class="o">-&gt;</span><span class="n">n_fatent</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">getFreeFs</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">;</span>
  <span class="n">free_sectors</span> <span class="o">=</span> <span class="n">free_clusters</span> <span class="o">*</span> <span class="n">getFreeFs</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">;</span>

  <span class="n">myprintf</span><span class="p">(</span><span class="s">"SD card stats:</span><span class="se">\r\n</span><span class="s">%10lu KiB total drive space.</span><span class="se">\r\n</span><span class="s">%10lu KiB available.</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_sectors</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">free_sectors</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">//Now let's try to open file "test.txt"</span>
  <span class="n">fres</span> <span class="o">=</span> <span class="n">f_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fil</span><span class="p">,</span> <span class="s">"test.txt"</span><span class="p">,</span> <span class="n">FA_READ</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fres</span> <span class="o">!=</span> <span class="n">FR_OK</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"f_open error (%i)</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">myprintf</span><span class="p">(</span><span class="s">"I was able to open 'test.txt' for reading!</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">//Read 30 bytes from "test.txt" on the SD card</span>
  <span class="n">BYTE</span> <span class="n">readBuf</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>

  <span class="c1">//We can either use f_read OR f_gets to get data out of files</span>
  <span class="c1">//f_gets is a wrapper on f_read that does some string formatting for us</span>
  <span class="n">TCHAR</span><span class="o">*</span> <span class="n">rres</span> <span class="o">=</span> <span class="n">f_gets</span><span class="p">((</span><span class="n">TCHAR</span><span class="o">*</span><span class="p">)</span><span class="n">readBuf</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fil</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">rres</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"Read string from 'test.txt' contents: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"f_gets error (%i)</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fres</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//Be a tidy kiwi - don't forget to close your file!</span>
  <span class="n">f_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fil</span><span class="p">);</span>

  <span class="c1">//Now let's try and write a file "write.txt"</span>
  <span class="n">fres</span> <span class="o">=</span> <span class="n">f_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fil</span><span class="p">,</span> <span class="s">"write.txt"</span><span class="p">,</span> <span class="n">FA_WRITE</span> <span class="o">|</span> <span class="n">FA_OPEN_ALWAYS</span> <span class="o">|</span> <span class="n">FA_CREATE_ALWAYS</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fres</span> <span class="o">==</span> <span class="n">FR_OK</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"I was able to open 'write.txt' for writing</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"f_open error (%i)</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fres</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//Copy in a string</span>
  <span class="n">strncpy</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">readBuf</span><span class="p">,</span> <span class="s">"a new file is made!"</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
  <span class="n">UINT</span> <span class="n">bytesWrote</span><span class="p">;</span>
  <span class="n">fres</span> <span class="o">=</span> <span class="n">f_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fil</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesWrote</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fres</span> <span class="o">==</span> <span class="n">FR_OK</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"Wrote %i bytes to 'write.txt'!</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bytesWrote</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="n">myprintf</span><span class="p">(</span><span class="s">"f_write error (%i)</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//Be a tidy kiwi - don't forget to close your file!</span>
  <span class="n">f_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fil</span><span class="p">);</span>

  <span class="c1">//We're done, so de-mount the drive</span>
  <span class="n">f_mount</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="cm">/* USER CODE END 2 */</span>

  <span class="cm">/* Infinite loop */</span>
  <span class="cm">/* USER CODE BEGIN WHILE */</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* USER CODE END WHILE */</span>

    <span class="cm">/* USER CODE BEGIN 3 */</span>
      <span class="c1">//Blink the LED every second</span>
	  <span class="n">HAL_GPIO_TogglePin</span><span class="p">(</span><span class="n">LD2_GPIO_Port</span><span class="p">,</span> <span class="n">LD2_Pin</span><span class="p">);</span>
	  <span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/* USER CODE END 3 */</span>
</code></pre></div></div>

<p>Alright, you’re ready to go!</p>

<p>Compile and download the project to your microcontroller. In your terminal, you should see the following appear!</p>

<p><img src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/output.png" alt="Output" class="mx-auto d-block"></p>

<p>If so, great! If not, rats.</p>

<p>If any numerical errors are given you can convert them into their meaning from the look up table in <code class="language-plaintext highlighter-rouge">Middlewares\Third_Party\FatFS\src\ff.h</code>.
 You should double check your wiring as well. Sadly, not all SD cards 
will work over SPI - I wasted a good few hours with a Kingston SD card 
before changing to an Apacer one that just worked instantly. Good luck!</p>

<p>Also note that if you’re using this process with your own custom 
circuit, you may need pull-up resistors on the SCK, MISO, and MOSI 
lines. The SD card module I used in this post includes them internally -
 if you’re wiring your own design, you might find you need to add them. 
You can also consider enabling the internal pull up resistors. More 
details are included <a href="https://github.com/kiwih/cubeide-sd-card/issues/2">here</a>.</p>

<p>If you would like the complete code that accompanies this blog post, it is made available in the associated Github repository <a href="https://github.com/kiwih/cubeide-sd-card">here</a>.</p>

      </article>

      
        <div class="blog-tags">
          Tags:
          
          
            <a href="https://01001000.xyz/tags#tutorial">tutorial</a>
          
            <a href="https://01001000.xyz/tags#stm32">stm32</a>
          
            <a href="https://01001000.xyz/tags#STM32CubeIDE">STM32CubeIDE</a>
          
            <a href="https://01001000.xyz/tags#embedded">embedded</a>
          
            <a href="https://01001000.xyz/tags#c">c</a>
          
          
        </div>
      

      
        <!-- Check if any share-links are active -->




<section id="social-share-section">
  <span class="sr-only">Share: </span>

  

  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2F01001000.xyz%2F2020-08-09-Tutorial-STM32CubeIDE-SD-card%2F" class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

</section>



      

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a class="page-link" href="https://01001000.xyz/2020-08-06-Updating-Firmware-Anet-A8-Board-1.7/" data-toggle="tooltip" data-placement="top" title="Walkthrough: Updating the Firmware on an Anet A8 (Mainboard Version 1.7)">← Previous Post</a>
        </li>
        
        
        <li class="page-item next">
          <a class="page-link" href="https://01001000.xyz/2020-10-24-Tutorial-STM32CubeIDE-Timers-PWM-AM-Radio/" data-toggle="tooltip" data-placement="top" title="Tutorial: Timers and PWM (and a cheeky AM radio transmission) using STM32CubeIDE">Next Post →</a>
        </li>
        
      </ul>
              
  
  
  

  



    </div>
  </div>
</div>


    <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="mailto:hammond.pearce@nyu.edu" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/kiwih" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://linkedin.com/in/hammond-pearce" title="LinkedIn">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">LinkedIn</span>
   </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
	  	© Hammond Pearce
        &nbsp;•&nbsp;
      
      2023

      

      
      </p>
      <!-- Please don't remove this, keep my open source work credited :) -->
      <p class="theme-by text-muted">
        Theme by
        <a href="https://beautifuljekyll.com/">beautiful-jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>

  
    
  
    
  <script src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>


  
    
  <script src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="Tutorial_%20An%20SD%20card%20over%20SPI%20using%20STM32CubeIDE%20and%20FatFS_files/main.js"></script>
    
  






  
  
  

</body></html>